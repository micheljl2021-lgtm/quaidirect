import { defineConfig, loadEnv } from "vite";
import react from "@vitejs/plugin-react-swc";
import path from "path";
import { componentTagger } from "lovable-tagger";
import compression from "vite-plugin-compression";
import fs from "fs";

// Plugin to inject cache version into service worker
function injectServiceWorkerVersion() {
  return {
    name: 'inject-sw-version',
    apply: 'build' as const,
    closeBundle() {
      const swPath = path.resolve(__dirname, 'dist/sw.js');
      if (fs.existsSync(swPath)) {
        const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, -5);
        let content = fs.readFileSync(swPath, 'utf-8');
        content = content.replace(/__CACHE_VERSION__/g, timestamp);
        fs.writeFileSync(swPath, content);
        console.log(`Service Worker cache version set to: ${timestamp}`);
      }
    }
  };
}

// https://vitejs.dev/config/
export default defineConfig(({ mode }) => {
  // Make sure env vars are available both in local dev (.env) and in Lovable Cloud builds (process.env)
  const loadedEnv = loadEnv(mode, process.cwd(), "");
  const getEnv = (key: string) => process.env[key] ?? loadedEnv[key];

  // Hard guarantee for the autogenerated Supabase client which expects VITE_* vars.
  // If the hosting environment provides SUPABASE_* vars, we map them into the VITE_* references at build-time.
  const supabaseUrl = getEnv("VITE_SUPABASE_URL") ?? getEnv("SUPABASE_URL") ?? "";
  const supabasePublishableKey =
    getEnv("VITE_SUPABASE_PUBLISHABLE_KEY") ??
    getEnv("SUPABASE_ANON_KEY") ??
    getEnv("SUPABASE_PUBLISHABLE_KEY") ??
    "";

  return {
    server: {
      host: "::",
      port: 8080,
    },
    define: {
      "import.meta.env.VITE_SUPABASE_URL": JSON.stringify(supabaseUrl),
      "import.meta.env.VITE_SUPABASE_PUBLISHABLE_KEY": JSON.stringify(supabasePublishableKey),
    },
    plugins: [
      react(),
      mode === "development" && componentTagger(),
      // Inject cache version into service worker
      injectServiceWorkerVersion(),
      // Gzip compression for production builds
      mode === "production" && compression({
        algorithm: "gzip",
        ext: ".gz",
        threshold: 10240,
      }),
      // Brotli compression for modern browsers
      mode === "production" && compression({
        algorithm: "brotliCompress",
        ext: ".br",
        threshold: 10240,
      }),
    ].filter(Boolean),
    resolve: {
      alias: {
        "@": path.resolve(__dirname, "./src"),
      },
    },
    build: {
      target: "es2020",
      rollupOptions: {
        external: [/\.test\.tsx?$/, /\.spec\.tsx?$/, /__tests__/],
        output: {
          manualChunks: {
            "vendor-react": ["react", "react-dom", "react-router-dom"],
            "vendor-ui": [
              "@radix-ui/react-dialog",
              "@radix-ui/react-dropdown-menu",
              "@radix-ui/react-select",
              "@radix-ui/react-tabs",
              "@radix-ui/react-toast",
              "@radix-ui/react-tooltip",
              "@radix-ui/react-popover",
            ],
            "vendor-query": ["@tanstack/react-query", "@supabase/supabase-js"],
            "vendor-maps": ["@react-google-maps/api", "@googlemaps/markerclusterer"],
            "vendor-charts": ["recharts"],
            "vendor-forms": ["react-hook-form", "@hookform/resolvers", "zod"],
            "vendor-date": ["date-fns", "react-day-picker"],
          },
        },
      },
      chunkSizeWarningLimit: 1000,
    },
    esbuild: {
      exclude: [
        '**/*.test.ts',
        '**/*.test.tsx',
        '**/*.spec.ts',
        '**/*.spec.tsx',
        '**/__tests__/**'
      ],
    },
  };
});

